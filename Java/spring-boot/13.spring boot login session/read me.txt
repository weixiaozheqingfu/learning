画时序图。


1.spring-boot-session 自定义实现redis会话。

2.spring-boot-session1 使用spring session实现redis会话。




 


1.登陆成功后cookie中存放jSessionId值。


2.前端发起请求，如果登陆会话失效，前端将cookie中jSessionId值清空。

3.防止同一客户端重复登陆：登陆成功后，如果再请求login页面，login页面会判断cookie中是否存在jSessionId，如果存在，则认为仍然处于会话状态（即使服务器到期了，也没关系），去请求首页，此时如果服务器会话没有过期，
  则服务器端验证jSessionId没有过期，处于登陆状态，则续期，并正常返回首页接口请求数据；如果服务器jSessionId过期，则返回会话失效，前端收到会话失效，则跳转至login登陆页。

  退一步讲，即使重复登陆，我们的代码逻辑也可以正常运转。因为如果同一客户端，或者说同一浏览器重复登陆后，会产生新的jSessionId到客户端cookie中。然后后续都用这个新的jSessionId请求都没有问题。
  问题在于之前的老的jSessionId在服务器还是存在会话对象的，如果有人有办法拿到这个旧的jSessionId，是可以请求接口的。那么问题就在于有没有外者轻松能拿到这个旧的jSessionId。
  但是话说回来，如果才能拿到这个旧的jSessionId呢，如果保证它是安全的，别人拿不到，就没有问题了。旧的jSessionId是存在于cookie中的，cookie是存在于客户端的，并且是当前请求域中的，
  属于私密数据，如果你的电脑别人能随便用，那就无所谓安全了。而如果枚举去尝试几乎是不可能匹配这个旧的jSessionId的，何况还有请求次数的限流。
  一般会话是30分钟，如果30分钟还外者还没有拿到旧的jSessionId去服务器请求，30分钟后，服务器端的这个jSessionId就会过期，即使有什么办法拿到请求接口也是未登陆状态了。
  所以重复登陆的问题不需要考虑。
  
  
4.登陆成功后，前端发起任何其他请求，都会带着jSessionId，服务器端验证处于登陆状态，则进行数据返回，否则返回登陆失效，前端跳转到首页。

5.未登陆状态下，前端发起任何请求，jSessionId值为空，则服务器端验证jSessionId为空，表示未登陆，则返回未登陆。即使jSessionId不为空，服务器发现没有匹配的jSessionId，也是返回未登陆状态。


6.多个客户端登陆同一用户账户（不同的客户端jSessionId值不同）的问题，看业务需要，可以也行，不可以也行，如果不可以多端同时登陆，则进行程序代码限制即可。












拦截器thredLocal中只存jSessionId即可。不要存储sessionInfo，sessionInfo用的时候直接从redis中取，可以写到baseAction中封装一个公用方法。
这样当sessionInfo信息发生变化时，thredLocal是不用维护这种变化的，thredLocal最好的实践就是拦截器中赋值一次，出拦截器清空thredLocal，中间只用于从thredLocal取值，而不再有值的变化。
否则，代码的可读性就很差了。