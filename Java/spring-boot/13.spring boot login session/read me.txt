画时序图。


1.spring-boot-session 自定义实现redis会话。用户名密码方式登录。模拟传统session操作方式，session以整个对象的方式整存redis整取redis。

2.spring-boot-session1 自定义实现redis会话。用户名手机号验证码方式登录。模拟传统session操作方式，session对象以hashmap的方式存入redis，读取写入redis都是按照session的属性分别实时写入或读取。

3.spring-boot-session2 自定义实现redis会话。用户名邮箱验证码方式登录。不再模拟传统session的方式，会话信息分别单独进行存储，客户端需要维护多份类似jsessionId的凭证码，例如邮箱验证码，图形验证码，用户会话信息等都需要单独的凭证写入客户端cookie。

4.spring-boot-session3 自定义实现redis会话。用户名手机号验证码方式登录。不再模拟传统session的方式，会话信息分别单独进行存储，但都直接聚合到redis的一个hash的对象里，图形验证码，用户登陆信息，手机或邮箱验证码分别在hash中存入自己的key值。
                                            这样对于前后端交互依然是只用一个jsessionId即那个uuid， 轻量级的实现，前后端交互也是一个jessionId，但是代码中不再引入session对象的概念，直接对接redis的hashmap的方式实现前后端会话管理。

5.spring-boot-session4 使用spring session实现redis会话。加入注册流程，需要发邮件激活邮箱。 与自定义实现redis会话2比较像。自己实现归自己实现，明白原理之后，还是推荐使用spring session。


以上5中方式，最推荐的是第5种，spring boot的官方实现，比较通用，到哪都一样，学习成本较低，稳定性较高。
             其次推荐第1种，自定义session会话的典范。
             再推荐第2种，也比较好的实现了session会话，且存储方式与spring boot的官方实现比较接近。
             再推荐第4种，比较轻量级，结合了第1种和第3种的长处，又避免了对方的短处。明白了会话原理，代码直接与redis对接做会话管理，比较轻量级，也推荐使用。

             至于第3种，目前项目中是这种方式，不推荐，管理混乱，写出来，是让大家通过对比了解到他的弊端，进而以后不再使用这种方式。



应该可以区分出给用户提示：未登陆，被他端踢出，会话过期的情况。
建议：如果session中没有取到user信息，说明是没有登陆，可以进一步将getSession后的sessionId值与客户端传入的jsessionId进行对比，如果相等，说明是未登录状态，如果不相等，说明是会话过期状态。
当然这种建议也不太对。



1.登陆成功后cookie中存放jSessionId值。


2.前端发起请求，如果登陆会话失效，前端将cookie中jSessionId值清空。

3.防止同一客户端重复登陆：登陆成功后，如果再请求login页面，login页面会判断cookie中是否存在jSessionId，如果存在，则认为仍然处于会话状态（即使服务器到期了，也没关系），去请求首页，此时如果服务器会话没有过期，
  则服务器端验证jSessionId没有过期，处于登陆状态，则续期，并正常返回首页接口请求数据；如果服务器jSessionId过期，则返回会话失效，前端收到会话失效，则跳转至login登陆页。

  退一步讲，即使重复登陆，我们的代码逻辑也可以正常运转。因为如果同一客户端，或者说同一浏览器重复登陆后，会产生新的jSessionId到客户端cookie中。然后后续都用这个新的jSessionId请求都没有问题。
  问题在于之前的老的jSessionId在服务器还是存在会话对象的，如果有人有办法拿到这个旧的jSessionId，是可以请求接口的。那么问题就在于有没有外者轻松能拿到这个旧的jSessionId。
  但是话说回来，如果才能拿到这个旧的jSessionId呢，如果保证它是安全的，别人拿不到，就没有问题了。旧的jSessionId是存在于cookie中的，cookie是存在于客户端的，并且是当前请求域中的，
  属于私密数据，如果你的电脑别人能随便用，那就无所谓安全了。而如果枚举去尝试几乎是不可能匹配这个旧的jSessionId的，何况还有请求次数的限流。
  一般会话是30分钟，如果30分钟还外者还没有拿到旧的jSessionId去服务器请求，30分钟后，服务器端的这个jSessionId就会过期，即使有什么办法拿到请求接口也是未登陆状态了。
  所以重复登陆的问题不需要考虑。
  
  
4.登陆成功后，前端发起任何其他请求，都会带着jSessionId，服务器端验证处于登陆状态，则进行数据返回，否则返回登陆失效，前端跳转到首页。

5.未登陆状态下，前端发起任何请求，jSessionId值为空，则服务器端验证jSessionId为空，表示未登陆，则返回未登陆。即使jSessionId不为空，服务器发现没有匹配的jSessionId，也是返回未登陆状态。


6.多个客户端登陆同一用户账户（不同的客户端jSessionId值不同）的问题，看业务需要，可以也行，不可以也行，如果不可以多端同时登陆，则进行程序代码限制即可。












拦截器thredLocal中只存jSessionId即可。不要存储sessionInfo，sessionInfo用的时候直接从redis中取，可以写到baseAction中封装一个公用方法。
这样当sessionInfo信息发生变化时，thredLocal是不用维护这种变化的，thredLocal最好的实践就是拦截器中赋值一次，出拦截器清空thredLocal，中间只用于从thredLocal取值，而不再有值的变化。
否则，代码的可读性就很差了。





7.另外一种模拟传统session方式，seesion的读取都是时时读取redis的做法，获取session时，new出一个session对象，然后检查前端传的sessionId在redis中是否存在id条目，存在则赋值sessionId到session对象中，不再重写jsession到客户端。
  读取和设置session属性值到redis中都是时时的。只要访问了session对象，就一定能拿到session对象，并且客户端就开始处于广义会话期了。不管其传入的jseesionId是否在redis中存在，不存在，就new出一个合法的会话回写到客户端，合法就直接使用该session。
  简而言之，广义会话是只要用户访问了session，就会给用户返回一个正确的会话对象，之前存在就使用之前的并续期，之前不存在就创造一个并回写到客户端cookie中。事实上我们使用的就是广义会话，
  用户登录会话只是用户自行在广义会话中自定义的一部分属性值来完成登录验证而已，它是搭了广义session的顺风车并利用了其通信原理，即广义会话保证了客户端和服务器端的数据访问连贯一致性。
 
  并且实验这种做法时，采用手机号验证码登陆。



密码加盐,好好研究一下，搞彻底，搞一个真正符合加盐逻辑的。
注册流程，要发邮箱验证码，并进行验证。或者发邮箱超链接，用户进行点击验证。两种方式都要做一下，尤其第二种方式要参考成熟的业内做法，尤其是前端的跳转情况。
