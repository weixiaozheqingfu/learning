package com.glitter.spring.boot.adapter;

/**
 * 电脑针对外设提供了typec接口,外部设备与电脑交互数据就必须通过标准的typec接口的数据线进行数据传输。
 * 代码的上下文环境就是电脑，TypecService接口就是数据线电脑端的标准接口，代码中要与外界交互，就通过TypecService接口进行。
 * 进行数据传输。
 *
 * 而各个适配器实现类其实实现了TypecService接口的实现类，是"实实在在"的一根数据线，这根线的另外一头连接了其他适配的接口。
 * 适配器实现类一头实现了标准的TypecService接口,另外一头注入了其他适配接口，在方法内部可以调用其他适配接口的方法，这样就达到了适配的效果。
 *
 *
 * 适配器的本质是：一端是你标准的接口，另一端可能是各种类型接口做后续对接，两端的接口不一样（规格不一样），但要传递的参数是一样的(内容数据一样)。
 * 然后这一端的统一接口调用后，将参数传递给另外规格的接口做后续处理，这就打到了一种数据转换的效果,这个过程就好像一根数据线适配器一样,即为适配器模式。
 *
 * 外部看到和对接的是统一的input和output接口,内部悄悄使用其他接口做逻辑实现,将msg参数继续传递给新接口做后续流程。
 * 这样就是一根适配的数据线一头是标准接口,另一头实际是对应多个不同的接口,这样完成了数据传递时的适配对接。
 *
 *
 * TypecAdapterService是标准接口，实现类是实体的线，在线的这一端实现了这个标准接口，同时在实现类的内部也就是在线的另外一头，
 * 注入有（或者说连接了）其他不同规格的接口，然后通过实现类这根适配器数据线，就将数据（参数）继续传递给这些新规格接口继续调用执行后续流程。
 * 数据继续通过新接口流入新的外部设备（如himiService就是流入了投影仪）
 *
 * 现实中的转接线也是这样的，一个标准接口，然后连接了几根不同的细线（外部统一包裹，看上起像是一根线），
 * 这几根线在另外一头（也是这根细线内部呀）分别连接了不同的其他接口，数据就被传入到了不同的接口中，
 * 至于使用哪一个规格的接口，就看你外部是什么设备，往哪个规格的接口插入了。
 *
 * 代码也是同样的道理，只是我们更节约，我们不是每一个适配接口都调用一次，而是知道你使用什么外部设备后，
 * 你使用标准接口对接后，我们就专门找那个对应的细线适配器做调用。
 *
 * 所以adapter2的这个适配器示例比adapter适配器示例更形象。标准接口的参数是handler(细线的一部分)，相当于标准接口已经开了口子，可以插入不同的细线。
 * 越说越复杂了，忽略我这句话吧，文字表达不好反而容易弄巧成拙，人类很奇妙，有些东西只可意会，说出来就没意境，没感觉了，就好像诗歌一样。自己能领悟到就好了。
 * 文字表达的解释就随他去吧,不看也罢。
 *
 *
 * 了解了适配器的本质，剩下的事情就好办了，其实适配器模式也有多种形式，这些形式都是基于本质上的各种表象，万变不离其宗，灵活运用和掌握即可。
 *
 */
public interface TypecAdapterService {

    boolean supports(Object handler);

    /**
     * 可以将外设的数据传输给电脑
     */
    void input(String msg, Object handler);

    /**
     * 可以电脑数据传输给外设
     */
    void output(String msg, Object handler);

}
